

# 注意

> 回答问题：
>
> 1. 它是什么？
> 2. 它有什么作用？
> 3. 它是如何实现的？



## 基础

### 聊聊JS的继承

> JS并没有真正的继承，而是通过将父类中的属性拷贝到子类实例对象中实现继承或者利用原型链实现继承。
>
> 常见的继承方式：借助构造函数实现继承，借助原型链实现继承，将两种方式组合实现继承，和使用寄生式组合继承方式。
>
> 借助构造函数实现继承的，通过在子类对象中使用call()方法调用父类构造方法，将父类中定义的属性拷贝到子类实例对象中，实现继承，这种方式最大的缺点就是父类的方法不能共享，每个子类对象都有自己独立的父类方法。
>
> 借助原型链实现继承，通过修改子类构造函数的property属性执行父类的实例对象，实现共享父类的方法，这种方式缺点就是子类实例对象不仅共享父类的方法，还共享父类的属性。
>
> 将两种方式组合实现继承，将父类中的方法转移到父类原型对象中，然后在子类构造函数中使用call()方法调用父类构造函数，并且修改子类原型对象执行一个父类实例对象，这样既实现父类属性的独立，又实现父类方法的共享。
>
> 寄生式组合继承是对组合方式的改良，不在子类原型对象不在指向父类的实例对象，而是一个指向父类原型对象的普通实例对象。这样子类原型对象中没有多余的属性。



### 聊聊属性描述符

> 属性描述符是说明对象中属性的特性，分为数值属性描述符和访问属性描述符，分别对应了实例对象中的存储属性和计算型属性。存储属性是对象中真正保存数据的属性，而计算型属性并没有保存数据的内存空间，它只是通过getter和setter方法实现对其它数据的读写。
>
> 数值属性描述符有configuration、enumable、write、value，分别是属性特性是否可以配置，属性是否可被遍历出来，属性是否支持写入，属性的属性值。
>
> 访问属性描述符有configuration、enumable、get、set，分别是属性特性是否可以配置，属性是否可被遍历出来，计算型属性的getter和计算型属性的setter。



### 聊聊JS的原型对象与原型链

> 回答方式：
>
> 1. 原型对象是什么，从哪里来的？
> 2. 原型对象、构造函数和实例对象的关系，new一个对象如何关联原型对象
> 3. 原型链是个什么样子
>
> 在js中创建函数对象时会伴随着创建一个对象，这个对象就是一个原型对象，函数的prototype属性和原型对象contructor属性相互引用对方。当new一个该构造函数的实例对象时，这个实例对象的\_proto属性会指向该构造函数的原型对象。原型对象也是通过某个构造函数创建的，这个原型对象的\_proto属性它的原型对象，直到指向Object的原型对象，这样从实例对象开始形成了一条链表结构，这条链表就是一个原型链。
>
> 原型链常用来做继承、instanceof关键字也是通过原型链来实现的。



### js类型转换问题

> boolean为false情况：0，NaN，null，undefined，空字符串
>
> number分为两种：
>
> 1. 转换成NaN的情况，含有字母的字符串、对象类型、undefined，数组长度>1。
> 2. 转换成0的情况，null，空数组情况。
> 3. 转换成数字情况，数组元素为number类型并且长度为1。
>
> `==`和`===`的区别，前者会进行类型转换，然后再进行比较
>
> `==`运算符比较规则：
>
> 1. null==undefined
> 2. 如果双方都是基本类型，则转成number进行比较。
> 3. 如果其中一方为引用类型，则将双方转成字符串然后进行比较。





### 你能说说你常用的一些Object方法

> 1. Object.key(targetObj)：获取参数中对象的所有可枚举(enumable:true)的属性名，组成一个数组返回。`方法参数必须是对象`。
> 2. Object.values(targetObj)：获取参数中对象的所有可枚举(enumable:true)的属性值，组成一个数组返回。`方法参数必须是对象`。
>
> Object.defineProperty()：给对象添加属性，可以是存储属性，也可以是计算型属性
>
> Object.assign()
>
> Object.create()：创建一个以某个对象为原型对象的实例对象。
>
> Object.is()
>
> Object.getOwnPropertyNames()
>
> 
>
> 



## 将伪数组转成数组的方式

> 1. slice()+call
> 2. Array.from()
> 3. concat + apply
> 4. 三点运算符

```javascript
let obj = {
    0: 'a',
    1: 'b',
    2: 'c',
    3: 'd',
    length: 4
}

Array.prototype.slice.call(obj);

Array.from(obj);

Array.prototype.concat.apply([], obj)
```



## eventloop

> 回答思路：
>
> 1. eventloop是什么，用来干什么
> 2. 浏览器eventloop流程
> 3. nodejs的eventloop流程
> 4. 两者的比较
>
> eventloop事件循环，执行代码的最小单位是线程，当线程执行完成后就会退出，程序就会结束，为了保持程序的能实时与用户交互，就不能让线程退出，因此使用了事件循环机制保证程序一直等待处理事件。就像餐厅的服务员和后厨，服务员接待顾客，后厨做菜。
>
> eventloop实现原理：主线程与用户交互，对于一些异步任务交给各个不同职能的后台线程，后台线程执行完成，将回调函数放到任务队列中，主线程闲置时执行任务队列中的回调函数。
>
> 浏览器的eventloop：
>
> 浏览器页面包含一个主线程+n个后台线程，主线程用来处理与UI渲染、用户交互，后台线程用来处理耗时操作，例如定时器、I/O、ajax等操作，当后台线程执行完成后将回调函数添加到任务队列的队尾，主线程执行完执行栈中多有函数后，取出任务队列中的任务压入执行栈执行。
>
> 在浏览器eventloop中分为宏任务与微任务，每个宏任务中都包含一个微任务队列，每当执行完成一个宏任务，就清空该任务中的微任务队列。
>
> nodejs的eventloop：
>
> 一个事件循环阶段有6个阶段，针对不同的阶段建立不同的宏任务队列和2个共享的微任务队列。
>
> 4个宏任务队列：
>
> timerQueue
>
> IOQueue
>
> checkQueue
>
> closeQueue
>
> 2个微任务队列：
>
> nextTickQueue，用来保存process.nextTick()函数添加的回调函数
>
> otherQueue，用来保存promise
>
> 一阶段timer阶段和4阶段check阶段分别清空定时器任务队列和Immediate任务队列，在每个阶段如果微任务队列有任务，则先清空微任务队列。
>
> 每个阶段只清空对应队列的任务，例如在4阶段如果timer队列有任务，也要等到eventloop跳到1阶段才能执行。
>
> 如果各个队列没有任务时，eventloop会在停在4阶段进行休眠。

## Array和string都有哪些方法，如何使用？



## 如何实现数据双向绑定



## 原型链图



## 说一说箭头函数的this



## ES5和ES6如何定义对象和类包括其中的属性和方法

> ES5定义类属性和类方法



## new Person === new Person相等吗？

> 不相等，比较的变量的地址。

