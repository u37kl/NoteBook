## 浏览器缓存

> 浏览器缓存用来干什么的？
>
> 如何实现浏览器缓存的，即谈谈缓存策略，缓存的流程？
>
> 讲讲ETag与last-modifyed区别？

> 浏览器缓存：针对get请求，浏览器会将get方式请求获得的响应数据保存到本地，方便下次请求时可以快速响应。
>
> 缓存的目的：为了更快的响应数据，减轻服务器压力，和不必要的网络请求。
>
> 浏览器缓存分为两种缓存，强缓存和协商缓存。
>
> expires和max-age为强缓存，etag和last-modify为协商缓存。
>
> 介绍http1.1添加的cache-control字段，
>
> 1. max-age
> 2. no-cache
> 3. no-store
> 4. public
> 5. private：数据是否可以共享，即数据是否可以缓存在代理服务器中。
>
> 不想让浏览器缓存：cache-control：no-cache, private, max-age=0
>
> 协商缓存：last-modify和Etag
>
> 浏览器缓存流程：
>
> 1. get请求时首先判断max-age或者expires是否过期，设置max-age值就会忽略expires，现在expires的存在主要为了兼容性。
> 2. 如果过期则携带Etag或者last-modify给服务器。
> 3. 服务器根据etag或者last-modify字段查看资源是否更新，如果没有更新则返回304，让浏览器读缓存，更新了返回新数据，新的max-age、last-modify、etag。
>
> last-modify与Etag区别：
>
> ​		etag对资源进行摘要生成一个字符串，当资源改变时，摘要的字符串就会改变，根据字符串变化判断资源是否改变，而last-modify根据资源更新时间，将请求携带的更新时间与当前服务器资源的更新时间对比如果一样就没有发生改变。
>
> 选择Etag情况：
>
> 1. 只能精确到秒，对于那些频繁变更的资源，不要使用last-modify。
> 2. 有些资源会定期备份，内容没有变但是更新时间发生改变，这种不要使用last-modify。
>
> 选择last-modify情况：
>
> ​		last-modify性能比Etag高，因为每次请求时都会对资源进行一次摘要，因此对于那些需要那么精确的资源并且想要性能好一点可以使用last-modify。

> 代理缓存：对于有代理服务器的，客户端会直接从代理服务器中获取资源，如果代理服务器没有，则让代理服务器去源服务器找。
>
> 代理缓存就是为了减轻源服务器的压力。
>
> private 和 public，客户端请求的资源是否允许代理服务器缓存，一般用于共享数据。
>
> proxy-revalidate和must-revalidate：客户端过期时，是否先去代理缓存中找，must-revalidate直接从源服务器获取。
>
> s-maxage：设置代理缓存过期时间
>
> max-stale 和 min-fresh：设置代理缓存宽容度和新鲜度，max-stale表示即使代理缓存过期，只要过期时间没有超过max-stale值就可以使用。



## cookie、token、jwt

> cookie、token、session用来干什么的？为何要有这些东西
>
> 分别介绍cookie、session、token如何实现它们的功能
>
> cookie、session、token的优缺点

> 由于http是无状态的，每次请求都是相互独立的，对于那些需要一些权限的资源，需要进行身份验证才能使用，因此有了cookie、sessoin、token这些技术方案。
>
> cookie与session是用来会话跟踪的，记录各个请求的结果，实现请求间的数据共享。cookie一般与session配合使用，当用户访问需要登录权限的资源时，会先调用登录接口，服务会为合法用户创建一个内存空间用来保存这个用户信息以及之后请求时需要缓存的数据，并通过set-cookie字段返回一个sessionID，浏览器会将其保存在该域的cookie下，下次在访问服务器时携带这个sessionID服务器就会知道这个用户是谁是否有权限访问这个资源。
>
> 但是cookie-session尤其自身的缺点，cookie有跨域限制、并且容易收到CSRF和XSS攻击，session会为每个用户开辟内存空间实现会话跟踪，当用户访问量增大时，加重服务器压力，并且在进行服务器集群时，需要进行服务器之间的session实时共享，不仅增大每个服务器存储压力，还增大了网络传输压力。
>
> token的技术为了解决不需要共享数据的只验证身份的情况，用户在登录时，服务器会生成一个token，将用户信息进行签名并加密发送给用户，用户在请求时，只需要写到这个token就行，服务器只需要将token解密验证是否时该服务器的签名就可以知道这个用户是否合法。让http无状态化。
>
> cookie-session与token在我的眼里的区别时，session不仅可以验证身份，并且还有一份自己独立的内存空间，因此可以实现请求之间的数据共享。token是对session功能的剥离，只保留了身份验证的功能，就像身份证和个人档案的区别，都可以识别身份，但是个人档案更加详细全面的说明这个人。
>
> token优点：
>
> 1. token的兼容性比cookie好，cookie有可能被浏览器禁用，一些浏览器对cookie支持不好。
> 2. token没有跨域限制。
>
> token也有缺点：
>
> 1. 由于服务器只认token，谁拿到了token谁就是哪个合法用户，因此需要合理控制token的有效期。
> 2. token虽然提高服务器扩展性，让http再次无状态化，但是它不想session，session保存的内容可以被服务器更改，但是token一旦给用户在有效期内无法修改，如果token保存了一些权限信息，那么只能等token过期，或者强制token失效。
>
> 分布式session共享方面：
>
> 1. session实时共享，服务器压力会很大。
> 2. session与Ip绑定，session不共享，用户在哪个服务器生成的session，就由那个服务器一直处理，但是怕崩溃。
> 3. 建立sesson缓存集群，将sesson与业务服务器分离，业务服务器与session服务器通信，成本非常大。

## 聊聊https

> https是什么，它是用来干什么的。
>
> 它流程是啥，如何实现加密？传统RSA和现在的ECHDE加密

> https是http + tls，就是在应用层与传输层之间添加一层，用于对网络数据进行加密。
>
> 由于http协议明文传输的特点，因此在网络传输过程中容易被窃听、篡改、冒充，https针对这些问题，提供了数据加密、身份验证、数据完整性验证机制来保证数据能安全的传输到想要送达的人手里。
>
> 有两种秘钥交换算法，RSA和ECDHE算法
>
> 基于RSA的TLS的握手流程：
>
> 1. 客户端首先发送一个随机数，并携带当前浏览器支持的tls版本，支持的加密算法。
> 2. 服务器接收到随机数后，自己生成一个随机数并携带所选择的tls版本和加密算法发送给服务器。
> 3. 接着服务器会将自己的数字证书发送给浏览器。
> 4. 浏览器根据证书链验证服务器证书合法性(`可以扩展说说证书验证流程`)，从而实现对服务器进行身份验证。
> 5. 浏览器会再次生成一个随机数，并使用服务器的公钥对数据进行加密，并发送给服务器。
> 6. 浏览器和服务器各自通过这三个随机数生成一个对称加密的秘钥，对之前发送的数据进行加密并发送给对方，验证秘钥是否可以正常使用，此时tls握手结束。
>
> 基于ECDHE的TLS握手流程：
>
> 1. 客户端首先发送一个随机数，并携带当前浏览器支持的tls版本，支持的加密套件。
> 2. 服务器接收到随机数后，自己生成一个随机数并携带所选择的tls版本和加密套件发送给服务器。
> 3. 接着服务器会将自己的数字证书发送给浏览器，然后服务器生成一个随机数作为私钥，并通过ECHDE算法生成一个公钥，发送给浏览器。
> 4. 浏览器接收到服务器的证书验证服务器的身份，然后客户端也生成一个随机数作为私钥，并通过ECHDE算法生成一个公钥，发送给浏览器。
> 5. 此时浏览器和服务器根据自己的私钥和对方的公钥使用ECHDE算法生成同一个秘钥，并对之前发送的数据进行加密并发送给对方，验证秘钥是否可以正常使用，此时tls握手结束。
>
> RSA和ECDHE算法：
>
> RSA并没有向前保密，也就是说如果服务器私钥泄漏，如果黑客截获的用户之前和服务器所有的通信，那么直接对其进行解密获得明文。



## get和post区别

> get和post都是http请求方式，
>
> 从语义上看get请求是获取数据，post请求是提交数据。
>
> 从结构上，get请求的请求数据保存在请求头上，因此由于请求头有长度限制，因此只能传递一些简单的参数，并且格式只有两种方式query方式或者params方式，而且需要进行urlencoding编码。post请求的数据放在请求体中，因此没有这个限制，格式也多种多样。
>
> 浏览器对get请求进行缓存，这样可以减少不必要的流量浪费，加快响应速度，而post不会缓存。



## 正向代理与反向代理

> 



